# webpack (addin)
<!-- webpack gulp grunt -->
webpack v1.x  2014.02
webpack v2.x  2017.01
webpack v3.x  2017.06
webpack v4.x  4.32.2  2018 05
webpack v5.x  目前不是稳定的版本

npm info webpack 可以下载的版本， webpack 5.x-bate (公测的版本)


## 单页应用vue react

## 模块化
 - 命名空间 `jquery (function(){})(window)`
```
 var obj={}
 obj.type = obj.type || {}
 obj.type.method = function(){}
 obj.type.add = function(){}
 obj.type.sub = function(){}

 obj.addin = obj.addin || {}
 obj.addin.remove = function(){}
 obj.addin.append = function(){}
```


 - amd 和 cmd 规范，模块化
   requireJS   SeaJS  
	 异步加载     同步加载

 - commonJS 规范： node模块化机制，一个文件就是一个模块
   module.exports导出  require导入

 - ES module （ES6的模块化）
  
	 导出：export | export default
	 导入：import ... from 'xx'

 - css模块化
	 - OOCSS（面向对象CSS）

	 - AMCSS(属性模块) 避免使用过多的class

   vue scoped 
   style	scoped

	

## webpack 4.32.2
卸载旧的webpack版本 npm uninstall webpack -g
下载最新的版本 npm install webpack -g
检擦当前webpack 版本 webpack --version

需要在本地文件内下载webpack，初始化package.json文件
去下载webpack 和webpack-cli, 3.x的版本是不需要下载webpack-cli,webpack集成了webpack-cli,  4.x以上的版本没有集成，需要手动下载.
webpack 4.x以下的使用webpack app.js bundle.js  ---ok
4.x以上没用了，因为4.x增加了一个多入口命令打包`webpack app.js app1.js -o bundle.js`

如果不加入 --mode "development" 参数则默认是生产环境，会自动压缩代码

`webpack app.js app1.js -o bundle.js --mode "development"`



 - 入口
    命令行中写入口，配置文件中写

 - 出口
 - module js ts sass stylus less 图片.w文件，
 - plugins 


# JS ES6+ 转成ES5语法

 - 使用babel，需要下载 babel-loader @babel/core @babel/preset-env --save-dev
 - 下载后webpack打包后只能将我们es6+的语法转成ES5的语法，但是ES6的一些内置API和功能（Promise Set Map）Object.assign() 如果我们要实现这些这些，我们需要使用 垫片库（polyfill） npm install -D @babel/polyfill

 - polyfill 全局的垫片，开发库或者框架的话就需要使用另外的垫片，（局部垫片）
```js
全局垫片的配置
{
	"presets":[["@babel/preset-env",{
		"useBuiltIns":"usage",
		"targets":{
			 // chrome:"67"
			 "ie":"9"
		}
	}]]
}
```

## 局部垫片的使用
`npm install --save-dev @babel/plugin-transform-runtime   npm install --save @babel/runtime`

```js
局部垫片的配置
{
	"presets":["@babel/preset-env"],
	 "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "absoluteRuntime": false,
        "corejs": 2,
        "helpers": true,
        "regenerator": true,
        "useESModules": false
      }
    ]
  ] 
}

Module not found: Error: Can't resolve '@babel/runtime-corejs2/core-js/promise' in 'c:\Users\Gao\Desktop\code'
 @ ./app.js 1:0-62 6:15-23 6:45-53

需要下载一个包：npm install --save @babel/runtime-corejs2
```
   


## 转换TS文件
 - 写一个Ts文件内容
```ts
const NUM =5;
interface People{
	name:String,
	sex:String
}

function onePeople(peo: People){
	 console.log(`name: ${peo.name}`)
}
onePeople({
	name: "zhangsan",
	sex: "男"
})

```

 - 下载 npm install --save-dev typescript ts-loader ,新建tsconfig.json文件

```json
{
  "compilerOptions": {
    "module": "commonjs",// 模块的引入方式 commonjs
    "target": "es5", //把语法转换成ES5的代码
    "allowJs": true // ts中是否允许引入js
	},
	"include":[
		"./src/",
		"./"
	],
	"exclude":[
		 "node_modules"
	]
}
```
 - 在webpack.config.js文件中加一个转换loader
```js
{
		test:/\.tsx?$/,
		loader:"ts-loader",
		exclude:"/node_modules/"
}
```

#### 类型约束
http://microsoft.github.io/TypeSearch/



## 打包图片

 - 下载 file-loader `npm install file-loader --save-dev`
 - webpack.config.js配置相应的图片转换loader
```js
	{
			test:/\.(png|jpe?g|gif)$/,
			use:{
				loader: 'file-loader',
				options: {},
			},
	  }
```
 - 插件： `npm install -D url-loader`


 ## 打包css

  - 下载`npm install --save-dev css-loader style-loader`
	- 在webpack.config.js文件中配置一个loader
```js
{
	test:/\.css$/,
	use:[
		"style-loader", "css-loader"
	]
}
```

## 打包css预编译处理语言（scss , less, stylus）

 - 下载`npm install sass-loader node-sass --save-dev`
 - 在webpack.config.js文件中配置一个转换我们scss的loader
```js
{
	test:/\.scss$/,
	use:[
		"style-loader", "css-loader","sass-loader"
	]
}
```

## 添加CSS3前缀

  - `npm install -D postcss-loader autoprefixer`
  - 需要在css的loader中修改
```js
{
	test:/\.scss$/,
	use:[
		"style-loader", "css-loader","sass-loader","postcss-loader"
	]
}
```
 ## css模块化打包


  ## Plugins使用
HtmlWebpackPlugin
CleanWebpackPlugin
```js
npm install  -D clean-webpack-plugin

```

## sourceMap 的配置（快速定位到源码所在位置）
一个映射关系表

## webpackDevServer: 开启本地服务器（提升我们开发的效率）

 - 1、 package.json添加脚本：`webpack --watch`,有缺陷，为了解决这些缺陷，我们使用webpackDevServer

 - 2、webpack4.x `npm install webpack-dev-server -D`,在webpack.config.js中配置devServer属性, 在package.json加入脚本`"dev": "webpack-dev-server" `

 - dist下面没内容,将我们内容,存在内存,所以需要加其他配置

### HMR(热模块更新)
```js
------------------main.js-----------------
import "./app.css";
var btn = document.createElement("button")
btn.innerHTML = "新增按钮"

document.body.appendChild(btn)

btn.onclick=function(){
	var div = document.createElement("div");
	div.innerHTML="hahaha";
	document.body.appendChild(div);
}

------------app.css-------------
div:nth-of-type(odd){
	background: red;
}
```

### TreeShaking( 摇树) 在开发模式无效的,只有在production模式下才有效
将没有使用的方法不打包进去,就得开启treeShaking,只能使用ESmodul的引入的方式 ,CommonJS的引入是不可以的


## development 和 production模式

webpack-merge插件,  //object.assign()
// npm i -D webpack-merge 


## 第三方库的引入有2重方式：
 - 通过expose-loader 进行全局变量注入
 - 通过内置插件，webpack.ProvidePlugin对每个模块的的空间注入一个变量，然后去自动加载模块，就不用在每个文件内去引入import 或者require

第一种：
 1、 npm i -D expose-loader
 2、配置loader
```js
{
			test:require.resolve("jquery"),// require.resolve用来获取模块的绝对路径，这里的loader只会作用于jquery
			use:{
				loader:"expose-loader",
				options:"$"
			}
		}
```

第二种：如果不像每个模块都导入 import jquery,想直接使用，对每个模块的闭空间注入一个变量，自动加载这个模块
```js
new webpack.ProvidePlugin({
		$:"jquery",
		jQuery:"jquery"
	})
```

## 反向代理

 跨域的解决方式：
  - JSONP (很少用)
	- cors ()
	- proxy代理


## 代码分割（代码分割和webpack无关，用来提升性能）

 - 入口起点：使用entry配置手动的分离代码
  将不同的文件内引入的相同的库会分别打包到不同的文件中

 - 防止重复：使用SplitChunksPlugin去重和分离chunk
	webpack提供一个拆分代码（code Spliting）, webpack 4.x使用的插件 SplitChunkPlugin，以前使用CommonChunkPlugin这个插件已经被移除了，

	只要在配置文件中
```js
optimization:{
	splitChunks:{
		chunks:"all"
	}
}

```

 - 动态导入：通过模块的懒加载调用来分离代码
webpack4 默认允许import语法动态导入，它ES7的提交草案，需要babel的插件支持，最新版的babel插件包`
@babel/plugin-syntax-dynamic-import`  注意：动态导入的最大好处是实现了懒加载，用到某个模块就加载哪个模块，SPA vue react路由懒加载 原理一样

 1、下载插件`npm i -D @babel/plugin-syntax-dynamic-import`
 2、配置babelrc文件
```js
"plugins": [
	"@babel/plugin-syntax-dynamic-import"
] 
```

```js
optimization: {
    splitChunks: {
      chunks: 'all', // 3个值async initial， all,针对异步，同步，所有代码做分割
      minSize: 30000, // 引入的包或者模块大于30000个字节才会做代码分割,针对于同步加载的模块才有效
      maxSize: 0, // 可配置，也不可配置，当打包的内容超出这个值之后，会尝试二次打包，但是拆分不了的部分，就无法拆分，不太常用
      minChunks: 2, // 引入次数，引入次数为 n 可以打包
      maxAsyncRequests: 5, // 异步加载时同时发送的请求数量不能超过5个，超过5个的部分不才分，一般不去修改
      maxInitialRequests: 3,// 页面初始化时同时发送的请求数量最大不能超过3个，超过的3个部分就不ibei拆分
      automaticNameDelimiter: '~', //打包出来的文件名的默认连接符
      // automaticNameMaxLength: 30, // 文件名最长不能超过30个字符
      name: true,  // 拆分的chunk名，true 表示根据模块名和CacheGroup组的key来自动生成，使用上面的连接符
      cacheGroups: { // 缓存配置：一个文件内import 多个库，如果需要将多个库打包在一个文件内就要缓存,所以命名为缓存组
        vendors: {
          test: /[\\/]node_modules[\\/]/, // 监测引入的库是否是node_modules下的，jquery，lodash，
          priority: -10 //权重：决定哪个组优先匹配，比如：node_modules下面有模块要拆分，如果同时后满足vendors ，default组，哪个priority值大，就按照哪个组去打包
				},
        default: { // 
          minChunks: 2,
          priority: -20,
					reuseExistingChunk: true // 当main.js引入 a.js,b.js, 但是a 中引入了b，就会重复引用，开始这个属性之后，就不会重复打包b.js,会复用
        }
      }
    }
  }
```

## 懒加载和Chunk
```js
async function getComponent(){
	const {default: $} = await import(/* webpackChunkName:"jquery" */ "jquery");
	$("body").append( $("<div></div>").html("main") )
}

document.addEventListener("click",()=>{
	getComponent()
})


-----------------babelrc------------------------
{
	"presets":[ [
		"@babel/preset-env",
		{
			"targets":{ "browsers" :["last 2 chrome versions"]},
			"useBuiltIns": "usage"
		}
	]],
	 "plugins": [
		"@babel/plugin-syntax-dynamic-import"
  ] 
}
```
chunk 块

## 打包分析

脚本加入  --profile --json > stats.json
生成stats.json ，就是我们分析打包流程的文件，对打包过程的一个描述

第二种插件方式分析：

1、 npm install --save-dev webpack-bundle-analyzer

## 预加载(preloading prefetching)

在网络空闲的时候，即首页的核心代码加载完成之后，再偷偷的去加载登陆的js代码，即预加载

```js
import(/* webpackPrefetch: true */ "./app.js").then(({default: func})=>{
		  func()
})
```
缓存带来的代码提升是有限的，所以懒加载代码优化成为我们性能提升的最重要的方式

## css文件做代码分割

 - 1. npm i -D mini-css-extract-plugin
 - 2.
```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
plugins: [
	new MiniCssExtractPlugin({})
]

--------------将css的loader中的"style-loader" 换成 MiniCssExtractPlugin.loader就ok
```

## css的压缩

 1、 npm i -D optimize-css-assets-webpack-plugin
 2、 添加optimization属性
 ```js
 optimization: {
    minimizer: [new OptimizeCSSAssetsPlugin({})],
  },
 ```

 ## webpack 浏览器的文件存储

 ## 环境变量vue -cli

 ## resolve参数配置
1、 npm i -S vue
2、 npm i -D vue-loader vue-template-compiler
vue-loader只要是15.x版本就需要配置一个插件


 ## webpack 打包速度优化

 - 更新我们的node 或者 npm 或者webpack
 - 尽可能的减少loader转换，（exclude:"node_modules",include:"./scr"）
 - Plugin(少用非官方提供的插件)
 - 使用DllPlugin提高打包的速度

```
1 、创建webpack.dll.js
```


## webpack 怎么去打包自己写的插件（库） axios库

1，npm login 
2. npm publish    401/403
3. npm config get registry
4. npm config set registry=http://registry.npmjs.org/
5. npm publish
6. 代码有更新，重新publish，


 
